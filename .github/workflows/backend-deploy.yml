name: Backend Production Deployment

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - '.github/workflows/backend-deploy.yml'
  workflow_dispatch:
    inputs:
      deploy_functions:
        description: 'Deploy Edge Functions'
        required: false
        default: true
        type: boolean
      deploy_migrations:
        description: 'Deploy Database Migrations'
        required: false
        default: true
        type: boolean
      deploy_policies:
        description: 'Deploy RLS Policies'
        required: false
        default: false
        type: boolean

concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  validate-backend:
    name: Validate Backend Code
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: üîÑ Checkout repository
      uses: actions/checkout@v4
      
    - name: ü¶ï Setup Deno
      uses: denoland/setup-deno@v2
      with:
        deno-version: v2.4.x
        
    - name: üîß Verify Deno installation
      run: |
        deno --version
        echo "‚úÖ Deno is ready for TypeScript compilation checks"
        
    - name: üîç TypeScript compilation check
      working-directory: ./backend
      run: |
        # Check if TypeScript files can be compiled using Deno
        find supabase/functions -name "*.ts" -type f | while read -r file; do
          echo "Checking TypeScript syntax: $file"
          deno check "$file" || {
            echo "‚ùå TypeScript error in $file"
            exit 1
          }
        done
        echo "‚úÖ All TypeScript files are valid"
        
    - name: üß™ Validate Edge Function structure
      working-directory: ./backend
      run: |
        echo "üîç Validating Edge Function structure..."
        
        # Check that each function has an index.ts file (exclude _shared directory)
        for func_dir in supabase/functions/*/; do
          func_name=$(basename "$func_dir")
          
          # Skip _shared directory as it's not a function
          if [ "$func_name" = "_shared" ]; then
            echo "‚ÑπÔ∏è Skipping _shared directory (utility/shared code)"
            continue
          fi
          
          if [ ! -f "${func_dir}index.ts" ]; then
            echo "‚ùå Missing index.ts in function: $func_name"
            exit 1
          fi
          
          # Check for basic Deno serve pattern
          if ! grep -q "Deno.serve" "${func_dir}index.ts"; then
            echo "‚ö†Ô∏è Function $func_name might not follow Deno.serve pattern"
          fi
          
          echo "‚úÖ Function $func_name structure is valid"
        done
        
    - name: üîí Security scan
      working-directory: ./backend
      run: |
        echo "üîí Running basic security checks..."
        
        # Check for potential security issues
        if grep -r "console.log.*password\|console.log.*secret\|console.log.*key" supabase/functions/ 2>/dev/null; then
          echo "‚ö†Ô∏è Found potential credential logging"
        fi
        
        # Check for hardcoded URLs
        if grep -r "localhost\|127.0.0.1" supabase/functions/ --exclude-dir=node_modules 2>/dev/null; then
          echo "‚ÑπÔ∏è Found localhost references (may be intentional for dev)"
        fi
        
        echo "‚úÖ Security scan completed"

  deploy-to-production:
    name: Deploy to Production Environment
    runs-on: ubuntu-latest
    needs: validate-backend
    timeout-minutes: 15
    environment: production
    
    outputs:
      DEPLOY_ENV: ${{ steps.env-setup.outputs.deploy_env }}
      PROJECT_REF: ${{ steps.env-setup.outputs.project_ref }}
      
    steps:
    - name: üîÑ Checkout repository
      uses: actions/checkout@v4
      
    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: üîß Install Supabase CLI
      run: |
        # Install Supabase CLI using GitHub releases (latest version)
        SUPABASE_VERSION="2.33.9"
        curl -fsSL "https://github.com/supabase/cli/releases/download/v${SUPABASE_VERSION}/supabase_linux_amd64.tar.gz" | tar -xz -C /tmp
        sudo mv /tmp/supabase /usr/local/bin/supabase
        chmod +x /usr/local/bin/supabase
        
    - name: ‚úÖ Verify Supabase CLI
      run: |
        # Make sure CLI is accessible
        supabase --version
        echo "‚úÖ Supabase CLI is ready"
      
    - name: üîç Setup production environment
      id: env-setup
      run: |
        echo "DEPLOY_ENV=production" >> $GITHUB_ENV
        echo "PROJECT_REF=${{ secrets.SUPABASE_PROJECT_REF }}" >> $GITHUB_ENV
        echo "deploy_env=production" >> $GITHUB_OUTPUT
        echo "project_ref=${{ secrets.SUPABASE_PROJECT_REF }}" >> $GITHUB_OUTPUT
        
        echo "üéØ Deploying to: production"
        echo "üìç Project reference: ${{ secrets.SUPABASE_PROJECT_REF }}"
      
    - name: ‚úÖ Validate Supabase connection
      working-directory: ./backend
      run: |
        export PATH="$HOME/.local/bin:$PATH"
        echo "üîó Testing Supabase connection to production..."
        if [ -z "${{ secrets.SUPABASE_PROJECT_REF }}" ]; then
          echo "‚ùå Project reference not set for production"
          exit 1
        fi
        supabase projects list > /dev/null
        echo "‚úÖ Supabase connection successful"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        
    - name: üìù Create production environment file
      working-directory: ./backend
      run: |
        echo "üìù Creating production environment file..."
        cat > .env.production << EOF
        # Supabase Configuration (Production)
        SUPABASE_PROJECT_REF=${{ secrets.SUPABASE_PROJECT_REF }}
        SUPABASE_ACCESS_TOKEN=${{ secrets.SUPABASE_ACCESS_TOKEN }}
        SUPABASE_URL=https://${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co
        SUPABASE_ANON_KEY=${{ secrets.SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_ROLE_KEY=${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        
        # LLM Configuration (Production)
        OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
        ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
        LLM_PROVIDER=${{ secrets.LLM_PROVIDER || 'openai' }}
        
        # Authentication (Production)
        GOOGLE_OAUTH_CLIENT_ID=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
        GOOGLE_OAUTH_CLIENT_SECRET=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET }}
        
        # Application URLs (Production)
        SITE_URL=https://disciplefy.vercel.app
        ADDITIONAL_REDIRECT_URLS=http://localhost:59641/auth/callback,https://disciplefy.vercel.app/auth/callback,com.disciplefy.bible_study_app://auth/callback
        
        # Security (Production)
        JWT_SECRET=${{ secrets.JWT_SECRET }}
        
        # Production settings
        LOG_LEVEL=error
        USE_MOCK=false
        NODE_ENV=production
        ANONYMOUS_RATE_LIMIT=5
        AUTHENTICATED_RATE_LIMIT=10
        API_REQUEST_LIMIT=100
        EOF
        echo "‚úÖ Production environment file created"
    
    - name: üîó Link to Supabase project
      working-directory: ./backend
      run: |
        echo "üîó Linking to Supabase production project..."
        
        # Create database URL with embedded password to avoid interactive prompt
        DB_URL="postgresql://postgres.$(echo "${{ secrets.SUPABASE_PROJECT_REF }}" | tr -d '-'):$DB_PASSWORD@aws-0-ap-south-1.pooler.supabase.com:6543/postgres"
        
        # Link using database URL instead of interactive password
        supabase link --project-ref "${{ secrets.SUPABASE_PROJECT_REF }}" --db-url "$DB_URL"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
    
    - name: üóÑÔ∏è Deploy Database Migrations
      if: ${{ github.event.inputs.deploy_migrations != 'false' }}
      working-directory: ./backend
      run: |
        echo "üóÑÔ∏è Deploying database migrations to production..."
        if [ -d "supabase/migrations" ] && [ "$(ls -A supabase/migrations 2>/dev/null)" ]; then
          echo "Using linked project for database migrations..."
          # Create database URL for non-interactive migration
          DB_URL="postgresql://postgres.$(echo "${{ secrets.SUPABASE_PROJECT_REF }}" | tr -d '-'):$DB_PASSWORD@aws-0-ap-south-1.pooler.supabase.com:6543/postgres"
          supabase db push --db-url "$DB_URL"
          echo "‚úÖ Database migrations deployed to production"
        else
          echo "‚ÑπÔ∏è No migrations to deploy"
        fi
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
    
    - name: üîí Deploy RLS Policies
      if: ${{ github.event.inputs.deploy_policies == 'true' }}
      working-directory: ./backend
      run: |
        echo "üîí Deploying RLS policies to production..."
        if [ -d "supabase/policies" ] && [ "$(ls -A supabase/policies 2>/dev/null)" ]; then
          # Create database URL for non-interactive policy deployment
          DB_URL="postgresql://postgres.$(echo "${{ secrets.SUPABASE_PROJECT_REF }}" | tr -d '-'):$DB_PASSWORD@aws-0-ap-south-1.pooler.supabase.com:6543/postgres"
          
          for policy_file in supabase/policies/*.sql; do
            if [ -f "$policy_file" ]; then
              policy_name=$(basename "$policy_file" .sql)
              echo "üîê Applying policy: $policy_name"
              supabase db query --file "$policy_file" --db-url "$DB_URL"
            fi
          done
          echo "‚úÖ RLS policies deployed to production"
        else
          echo "‚ÑπÔ∏è No RLS policies to deploy"
        fi
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD }}
        
    - name: üì¶ Deploy Edge Functions
      if: ${{ github.event.inputs.deploy_functions != 'false' }}
      working-directory: ./backend
      run: |
        echo "üöÄ Deploying Edge Functions to production..."
        
        # Deploy all functions with production settings
        supabase functions deploy --no-verify-jwt
        
        echo "‚úÖ Edge Functions deployed successfully to production"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        
    - name: üîë Update Function Secrets
      working-directory: ./backend
      run: |
        echo "üîë Updating Edge Function secrets for production..."
        supabase secrets set --env-file .env.production
        echo "‚úÖ Function secrets updated for production"
      env:
        SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        
    - name: üß™ Test production deployment
      working-directory: ./backend
      run: |
        echo "üß™ Testing production deployment..."
        
        # Test health endpoint
        BASE_URL="https://${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co"
        
        if curl -f -s "$BASE_URL/rest/v1/" > /dev/null; then
          echo "‚úÖ Supabase REST API is healthy"
        else
          echo "‚ö†Ô∏è Supabase REST API test failed"
        fi
        
        # Test Edge Functions
        FUNCTIONS=("daily-verse" "topics-recommended")
        for func in "${FUNCTIONS[@]}"; do
          if curl -f -s "$BASE_URL/functions/v1/$func" > /dev/null; then
            echo "‚úÖ Function $func is responding"
          else
            echo "‚ö†Ô∏è Function $func test failed (may be expected for some functions)"
          fi
        done
        
        echo "üéâ Production deployment tests completed"
        
    - name: üìä Deployment summary
      run: |
        echo "üéâ Backend deployment to production completed!"
        echo "üåê Production API: https://${{ secrets.SUPABASE_PROJECT_REF }}.supabase.co"
        echo "üìã Deployed components:"
        echo "   ‚Ä¢ Edge Functions: ${{ github.event.inputs.deploy_functions != 'false' && '‚úÖ' || '‚è≠Ô∏è' }}"
        echo "   ‚Ä¢ Database Migrations: ${{ github.event.inputs.deploy_migrations != 'false' && '‚úÖ' || '‚è≠Ô∏è' }}"
        echo "   ‚Ä¢ RLS Policies: ${{ github.event.inputs.deploy_policies == 'true' && '‚úÖ' || '‚è≠Ô∏è' }}"
        echo "   ‚Ä¢ Function Secrets: ‚úÖ"
        
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "üîç This is a PR deployment for testing purposes"
          echo "üìù Review the changes and test the deployment before merging"
        fi
        
    - name: üßπ Security cleanup
      working-directory: ./backend
      if: always()
      run: |
        echo "üßπ Cleaning up sensitive files..."
        rm -f .env.production
        echo "‚úÖ Cleanup completed"

  comment-pr:
    name: Comment on PR
    runs-on: ubuntu-latest
    needs: deploy-to-production
    if: github.event_name == 'pull_request'
    
    steps:
    - name: üí¨ Comment deployment status
      uses: actions/github-script@v7
      with:
        script: |
          const deployEnv = '${{ needs.deploy-to-production.outputs.DEPLOY_ENV }}' || 'production';
          const projectRef = '${{ needs.deploy-to-production.outputs.PROJECT_REF }}';
          
          const comment = `## üöÄ Backend Production Deployment
          
          **Environment**: \\`production\\`
          **Status**: ‚úÖ Deployment Successful
          
          ### üîó Test URLs:
          - **API Base**: https://${projectRef}.supabase.co
          - **Functions**: https://${projectRef}.supabase.co/functions/v1/
          - **Studio**: https://app.supabase.com/project/${projectRef}
          
          ### üß™ Test Endpoints:
          - Daily Verse: https://${projectRef}.supabase.co/functions/v1/daily-verse
          - Topics: https://${projectRef}.supabase.co/functions/v1/topics-recommended
          
          **Note**: This deployment is for testing purposes. Changes will be deployed to production when this PR is merged to main.
          
          ---
          *Deployed from commit: ${context.sha.substring(0, 7)}*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate-backend, deploy-to-production]
    if: always() && github.event_name != 'pull_request'
    
    steps:
    - name: üì¢ Deployment notification
      run: |
        if [ "${{ needs.deploy-to-production.result }}" = "success" ]; then
          echo "üéâ Backend deployment to production was successful!"
          echo "üåê Production API is now live"
          echo "üöÄ Ready for production traffic"
        else
          echo "‚ùå Backend deployment failed. Check the logs above."
          exit 1
        fi