// ============================================================================
// Send Recommended Topic Notification Edge Function
// ============================================================================
// Sends recommended Bible study topic push notifications to all eligible users
// Triggered by GitHub Actions workflow at 8 AM across different timezones

import { createSimpleFunction } from '../_shared/core/function-factory.ts'
import { ServiceContainer } from '../_shared/core/services.ts'
import { FCMService, logNotification } from '../_shared/fcm-service.ts'
import { selectNotificationForUser } from '../_shared/unified-notification-selector.ts'
import {
  createNotificationHelper,
  NotificationUser,
} from '../_shared/services/notification-helper-service.ts'
import { AppError } from '../_shared/utils/error-handler.ts'

// ============================================================================
// Types
// ============================================================================

interface RecommendedTopicUser extends NotificationUser {
  readonly timezone_offset_minutes: number
}

// ============================================================================
// Note: Notification titles and bodies are now generated by unified-notification-selector
// to support both "Continue Learning" and "For You" notification types
// ============================================================================

// ============================================================================
// Helper Functions
// ============================================================================

function calculateTimezoneOffsetRange(currentHour: number): { offsetRangeMin: number; offsetRangeMax: number } {
  let targetOffsetMinutes = (8 - currentHour) * 60 // 8 AM target

  // Normalize to valid timezone range: -720 (UTC-12) to +840 (UTC+14)
  if (targetOffsetMinutes < -720) {
    targetOffsetMinutes += 1440
  } else if (targetOffsetMinutes > 840) {
    targetOffsetMinutes -= 1440
  }

  const offsetRangeMin = Math.max(-720, targetOffsetMinutes - 180)
  const offsetRangeMax = Math.min(840, targetOffsetMinutes + 180)

  return { offsetRangeMin, offsetRangeMax }
}

async function getUserTokensPage(
  supabase: ServiceContainer['supabaseServiceClient']
): Promise<Array<{ user_id: string; fcm_token: string }>> {
  const { data: tokens, error: tokensError } = await supabase
    .from('user_notification_tokens')
    .select('user_id, fcm_token')

  if (tokensError) {
    throw new AppError('DATABASE_ERROR', `Failed to fetch tokens: ${tokensError.message}`, 500)
  }

  return tokens || []
}

async function fetchPreferencesInOffsetRange(
  supabase: ServiceContainer['supabaseServiceClient'],
  offsetRangeMin: number,
  offsetRangeMax: number
): Promise<Array<{ user_id: string; timezone_offset_minutes: number }>> {
  if (offsetRangeMin > offsetRangeMax) {
    const [result1, result2] = await Promise.all([
      supabase
        .from('user_notification_preferences')
        .select('user_id, timezone_offset_minutes, recommended_topic_enabled')
        .eq('recommended_topic_enabled', true)
        .gte('timezone_offset_minutes', offsetRangeMin)
        .lte('timezone_offset_minutes', 840),

      supabase
        .from('user_notification_preferences')
        .select('user_id, timezone_offset_minutes, recommended_topic_enabled')
        .eq('recommended_topic_enabled', true)
        .gte('timezone_offset_minutes', -720)
        .lte('timezone_offset_minutes', offsetRangeMax)
    ])

    if (result1.error || result2.error) {
      throw new AppError('DATABASE_ERROR', `Failed to fetch preferences: ${(result1.error || result2.error)!.message}`, 500)
    }

    return [...(result1.data || []), ...(result2.data || [])]
  }

  const { data, error } = await supabase
    .from('user_notification_preferences')
    .select('user_id, timezone_offset_minutes, recommended_topic_enabled')
    .eq('recommended_topic_enabled', true)
    .gte('timezone_offset_minutes', offsetRangeMin)
    .lte('timezone_offset_minutes', offsetRangeMax)

  if (error) {
    throw new AppError('DATABASE_ERROR', `Failed to fetch preferences: ${error.message}`, 500)
  }

  return data || []
}

function enrichUsersWithTimezone(
  tokens: Array<{ user_id: string; fcm_token: string }>,
  preferences: Array<{ user_id: string; timezone_offset_minutes: number }>
): RecommendedTopicUser[] {
  const prefsMap = new Map(preferences.map(p => [p.user_id, p]))
  return tokens
    .filter(t => prefsMap.has(t.user_id))
    .map(t => ({
      user_id: t.user_id,
      fcm_token: t.fcm_token,
      timezone_offset_minutes: prefsMap.get(t.user_id)!.timezone_offset_minutes
    }))
}

/**
 * Fetches users eligible for recommended topic notifications within specified timezone offset range.
 * Returns users with FCM tokens who have enabled recommended topic notifications.
 *
 * @param supabase - Supabase service client for database operations
 * @param offsetRangeMin - Minimum timezone offset in minutes (UTC-12 = -720)
 * @param offsetRangeMax - Maximum timezone offset in minutes (UTC+14 = +840)
 * @returns Array of users with FCM tokens and timezone offsets
 */
async function fetchEligibleUsersWithTimezone(
  supabase: ServiceContainer['supabaseServiceClient'],
  offsetRangeMin: number,
  offsetRangeMax: number
): Promise<RecommendedTopicUser[]> {
  const tokens = await getUserTokensPage(supabase)
  const preferences = await fetchPreferencesInOffsetRange(supabase, offsetRangeMin, offsetRangeMax)
  return enrichUsersWithTimezone(tokens, preferences)
}

async function computeUsersToNotify(
  notificationHelper: ReturnType<typeof createNotificationHelper>,
  authenticatedUsers: RecommendedTopicUser[]
): Promise<RecommendedTopicUser[]> {
  const userIds = authenticatedUsers.map(u => u.user_id)
  const [alreadySentRecommended, alreadySentContinue] = await Promise.all([
    notificationHelper.getAlreadySentUserIds(userIds, 'recommended_topic'),
    notificationHelper.getAlreadySentUserIds(userIds, 'continue_learning'),
  ])
  const alreadySentUserIds = new Set([...alreadySentRecommended, ...alreadySentContinue])
  return authenticatedUsers.filter(u => !alreadySentUserIds.has(u.user_id))
}

function buildNotificationData(
  notification: { type: string; topicId: string; topicTitle: string; topicDescription: string; guideId?: string; timeSpent?: number },
  language: string
): Record<string, string> {
  const data: Record<string, string> = {
    type: notification.type,
    topic_id: notification.topicId,
    topic_title: notification.topicTitle,
    topic_description: notification.topicDescription,
    language,
  }

  if (notification.type === 'continue_learning' && notification.guideId) {
    data.guide_id = notification.guideId
    data.time_spent = notification.timeSpent?.toString() || '0'
  }

  return data
}

async function sendSingleNotification(
  user: RecommendedTopicUser,
  language: string,
  fcmService: FCMService,
  supabaseUrl: string,
  serviceRoleKey: string
): Promise<{ success: boolean; topicSelectionFailed?: boolean; topicId?: string; notificationType?: string }> {
  try {
    const notificationResult = await selectNotificationForUser(supabaseUrl, serviceRoleKey, user.user_id, language)

    if (!notificationResult.success || !notificationResult.notification) {
      console.error(`[RecommendedTopic] Notification selection failed for user ${user.user_id}:`, notificationResult.error)
      return { success: false, topicSelectionFailed: true }
    }

    const notification = notificationResult.notification
    const notificationData = buildNotificationData(notification, language)

    const result = await fcmService.sendNotification({
      token: user.fcm_token,
      notification: { title: notification.title, body: notification.body },
      data: notificationData,
      android: { priority: 'high' },
      apns: {
        headers: { 'apns-priority': '10' },
        payload: { aps: { sound: 'default', badge: 1 } },
      },
    })

    await logNotification(supabaseUrl, serviceRoleKey, {
      userId: user.user_id,
      notificationType: notification.type === 'continue_learning' ? 'continue_learning' : 'recommended_topic',
      title: notification.title,
      body: notification.body,
      topicId: notification.topicId || undefined,
      language,
      deliveryStatus: result.success ? 'sent' : 'failed',
      fcmMessageId: result.messageId,
      errorMessage: result.error,
    })

    return { success: result.success, topicId: notification.topicId, notificationType: notification.type }
  } catch (error) {
    console.error(`[RecommendedTopic] Error for user ${user.user_id}:`, error)
    return { success: false }
  }
}

interface NotificationStats {
  successCount: number
  failureCount: number
  topicSelectionFailures: number
  uniqueTopicIds: Set<string>
  continueLearningCount: number
  forYouCount: number
}

async function sendNotificationBatch(
  users: RecommendedTopicUser[],
  languageMap: Map<string, string>,
  fcmService: FCMService,
  supabaseUrl: string,
  serviceRoleKey: string
): Promise<NotificationStats> {
  const stats: NotificationStats = {
    successCount: 0,
    failureCount: 0,
    topicSelectionFailures: 0,
    uniqueTopicIds: new Set<string>(),
    continueLearningCount: 0,
    forYouCount: 0,
  }

  const BATCH_SIZE = 10

  for (let i = 0; i < users.length; i += BATCH_SIZE) {
    const batch = users.slice(i, i + BATCH_SIZE)
    const results = await Promise.allSettled(
      batch.map(user => sendSingleNotification(user, languageMap.get(user.user_id) || 'en', fcmService, supabaseUrl, serviceRoleKey))
    )

    results.forEach(result => {
      if (result.status === 'fulfilled') {
        const value = result.value
        if (value.topicSelectionFailed) {
          stats.topicSelectionFailures++
          stats.failureCount++
        } else if (value.success) {
          stats.successCount++
          if (value.topicId) stats.uniqueTopicIds.add(value.topicId)
          if (value.notificationType === 'continue_learning') stats.continueLearningCount++
          else if (value.notificationType === 'for_you') stats.forYouCount++
        } else {
          stats.failureCount++
        }
      } else {
        stats.failureCount++
      }
    })

    console.log(`[RecommendedTopic] Batch ${Math.floor(i / BATCH_SIZE) + 1} complete: ${stats.successCount} sent, ${stats.failureCount} failed`)
  }

  return stats
}

async function prepareUserNotifications(
  supabase: ServiceContainer['supabaseServiceClient'],
  notificationHelper: ReturnType<typeof createNotificationHelper>,
  offsetRangeMin: number,
  offsetRangeMax: number
): Promise<{ usersToNotify: RecommendedTopicUser[]; languageMap: Map<string, string> } | Response> {
  const allUsers = await fetchEligibleUsersWithTimezone(supabase, offsetRangeMin, offsetRangeMax)
  if (allUsers.length === 0) return notificationHelper.createSuccessResponse('No eligible users', { sentCount: 0 })
  console.log(`[RecommendedTopic] Found ${allUsers.length} users with tokens`)

  const authenticatedUsers = await notificationHelper.filterAnonymousUsers(supabase, allUsers)
  if (authenticatedUsers.length === 0) return notificationHelper.createSuccessResponse('No authenticated users eligible', { sentCount: 0 })

  const usersToNotify = await computeUsersToNotify(notificationHelper, authenticatedUsers)
  console.log(`[RecommendedTopic] ${usersToNotify.length} users need notification`)
  if (usersToNotify.length === 0) return notificationHelper.createSuccessResponse('All users already received notification today', { sentCount: 0 })

  const languageMap = await notificationHelper.getUserLanguagePreferences(supabase, usersToNotify.map(u => u.user_id))
  return { usersToNotify, languageMap }
}

function isResponse(value: unknown): value is Response {
  return value instanceof Response
}

// ============================================================================
// Main Handler
// ============================================================================

/**
 * Handles sending recommended topic push notifications to eligible users at 8 AM in their timezone.
 * Uses unified notification selector to send either "Continue Learning" or "For You" notifications.
 *
 * @param req - HTTP request with cron secret for authentication
 * @param services - Service container with Supabase client and dependencies
 * @returns Response with notification statistics (success/failure counts, notification types)
 */
async function handleRecommendedTopicNotification(req: Request, services: ServiceContainer): Promise<Response> {
  const notificationHelper = createNotificationHelper()
  notificationHelper.verifyCronSecret(req)
  console.log('[RecommendedTopic] Starting notification process...')

  const { offsetRangeMin, offsetRangeMax } = calculateTimezoneOffsetRange(new Date().getUTCHours())
  console.log(`[RecommendedTopic] Offset range: ${offsetRangeMin} to ${offsetRangeMax}`)

  const result = await prepareUserNotifications(services.supabaseServiceClient, notificationHelper, offsetRangeMin, offsetRangeMax)
  if (isResponse(result)) return result

  const { usersToNotify, languageMap } = result
  const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!
  const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  const stats = await sendNotificationBatch(usersToNotify, languageMap, new FCMService(), SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

  console.log(`[RecommendedTopic] Complete: ${stats.successCount} sent (${stats.continueLearningCount} Continue, ${stats.forYouCount} ForYou)`)

  return notificationHelper.createSuccessResponse('Unified notifications sent (Continue Learning + For You)', {
    totalEligible: usersToNotify.length,
    successCount: stats.successCount,
    failureCount: stats.failureCount,
    topicSelectionFailures: stats.topicSelectionFailures,
    uniqueTopicsSent: stats.uniqueTopicIds.size,
    continueLearningCount: stats.continueLearningCount,
    forYouCount: stats.forYouCount,
  })
}

// ============================================================================
// Start Server
// ============================================================================

createSimpleFunction(handleRecommendedTopicNotification, {
  allowedMethods: ['POST'],
  enableAnalytics: false,
})
